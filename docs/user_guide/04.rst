

Data processing 
===============

Filtering, windowing and other signal processing operations are essential for meaningful comparisons between data synthetics.  

To make data processing easier, `mtuq.ProcessData` represents an attempt at a one-size-fits-all data processing class.  

That said, the approach below based on `mtuq.ProcessData` is simply a suggestion.  Users are in fact free to apply their own custom functions instead, as long as the time discretization requirements below end up being satisfied.



`mtuq.ProcessData`
------------------

Data processing choices include filter type, window length, and many others.  With `mtuq.ProcessData`, the choice of such parameters is clearly separated from the actual application of the data processing function to the seismic data, resulting in a two-step procedure.

In the first step, the user supplies parameters to create a data processing function:

.. code::

    process_data = ProcessData(parameters)

See the API reference for detailed parameter descriptions.


In the second step, an ObsPy stream is given as input and a processed stream returned as output:

.. code::

    processed_stream = process_data(stream)


Data processing can also be applied to an entire ``Dataset`` at once:

.. code::

    processed_data = mtuq.Dataset()
    for stream in dataset:
        processed_stream = process_data(stream)
        processed_data += processed_stream


Or, even more succinctly, an entire ``Dataset`` can be processed by:

.. code::

    processed_dataset = dataset.map(function)



Time discretization requirements
--------------------------------

To make meaningful comparisons betweeen data and synthatics, windows must of course be chosen to include body wave and/or surface wave phases of interest.

Besides this one obvious requirement, two additional conditions turn out to be important for numerical efficiency and software engineering robustness:

1. all traces must have the same sampling rate and number of samples
2. all traces common to the same station must have the same startime and endtime

By imposing these time discretization requirements, MTUQ achieves faster memory access patterns, more efficent misfit evaluation, and more easily maintainable code than would otherwise be possible.

An easy way to ensure that the above requirements are satisfied is to simply use `mtuq.ProcessData` for data processing.

